require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const mongoose = require('mongoose');
const OpenAI = require("openai");
const { MongoClient } = require('mongodb');
const twilio = require('twilio');
const axios = require('axios');
const { google } = require('googleapis');

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Exemple de token stock√© en variable d'env (ou config)
const token = process.env.WHATSAPP_CLOUD_API_TOKEN || "TON_TOKEN_PERMANENT";
const whatsappPhoneNumberId = process.env.WHATSAPP_PHONE_NUMBER_ID || "TON_PHONE_NUMBER_ID";

// Configuration MongoDB
const mongoUri = process.env.MONGODB_URI;
if (!mongoUri) {
    console.error("‚ùå Erreur : MONGODB_URI n'est pas d√©fini dans les variables d'environnement.");
    process.exit(1);
}

const activeRuns = new Map(); // userNumber -> { threadId, runId }
const locks = new Map(); // userNumber -> bool
const messageQueue = new Map(); // userNumber -> array

let db;  // Variable pour stocker la connexion √† MongoDB

async function connectToMongoDB() {
  try {
    const mongoClient = new MongoClient(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true });
    await mongoClient.connect();
    db = mongoClient.db('chatbotDB');
    console.log("‚úÖ Connect√© √† MongoDB avec succ√®s !");
  } catch (err) {
    console.error("‚ùå Erreur lors de la connexion √† MongoDB :", err);
    process.exit(1);
  }
  await db.collection('processedMessages').createIndex(
    { createdAt: 1 },
    { expireAfterSeconds: 86400 } // 86400 secondes = 24 heures
  );
  console.log("üßπ Index TTL activ√© sur processedMessages (expiration apr√®s 24h).");
}

// Appel de la connexion MongoDB
connectToMongoDB();

async function handleMessage(userMessage, userNumber) {
  if (!messageQueue.has(userNumber)) messageQueue.set(userNumber, []);
  messageQueue.get(userNumber).push(userMessage);
  console.log(`üßæ Message ajout√© √† la file pour ${userNumber} : "${userMessage}"`);
  
  // Si un traitement est d√©j√† en cours, on ne relance rien
  if (locks.get(userNumber)) return;

  locks.set(userNumber, true);
  console.log(`üîí Lock activ√© pour ${userNumber}`);

  try {
    // üîÅ R√©cup√©rer tous les messages actuels dans la file
    const initialQueue = [...messageQueue.get(userNumber)];
    console.log(`üìö File initiale de ${userNumber} :`, initialQueue);
    messageQueue.set(userNumber, []); // capter les nouveaux entre-temps
    
    const combinedMessage = initialQueue.join(". ");
    const { threadId, runId } = await interactWithAssistant(combinedMessage, userNumber);
    console.log(`üß† Assistant appel√© avec : "${combinedMessage}"`);
    console.log(`üìé threadId = ${threadId}, runId = ${runId}`);
    activeRuns.set(userNumber, { threadId, runId });
    
    // üß† V√©rification ici : y a-t-il eu d'autres messages pendant le run ?
    const newMessages = messageQueue.get(userNumber) || [];
    if (newMessages.length > 0) {
      console.log("‚ö†Ô∏è R√©ponse ignor√©e car nouveaux messages apr√®s envoi.");
      messageQueue.set(userNumber, [...initialQueue, ...newMessages]);
      locks.set(userNumber, false);
      return await handleMessage("", userNumber);
      console.log(`üì• Nouveaux messages d√©tect√©s pendant le run pour ${userNumber} :`, newMessages);
    }
    const messages = await pollForCompletion(threadId, runId);
    // ‚úÖ Sinon, envoyer la r√©ponse
    console.log(`üì¨ Envoi de la r√©ponse finale √† WhatsApp pour ${userNumber}`);
    await sendResponseToWhatsApp(messages, userNumber);

    await db.collection('threads1').updateOne(
      { userNumber },
      {
        $set: { threadId },
        $push: {
          responses: {
            userMessage: combinedMessage,
            assistantResponse: {
              text: messages.text,
              note: messages.note
            },
            timestamp: new Date()
          }
        }
      },
      { upsert: true }
    );
  console.log("üóÉÔ∏è R√©ponse enregistr√©e dans MongoDB pour", userNumber);
  } catch (error) {
    console.error("‚ùå Erreur dans handleMessage :", error);
  } finally {
    console.log(`üîì Lock lib√©r√© pour ${userNumber}`);
    locks.set(userNumber, false);

    const remaining = messageQueue.get(userNumber) || [];
    if (remaining.length > 0) {
      const next = remaining.shift();
      messageQueue.set(userNumber, [next, ...remaining]);
      await handleMessage("", userNumber); // relancer pour le prochain bloc
      console.log(`‚û°Ô∏è Message restant d√©tect√©, relance de handleMessage() pour ${userNumber}`);
    }
  }
}

// Middleware
app.use(cors({
  origin: 'https://www.puravivecoach.com', // Remplace par l'URL de ton front-end si n√©cessaire
  credentials: true
}));
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
app.use(cookieParser());
app.use(express.json()); // parse le JSON entrant de Meta

// Exportation de `db` pour pouvoir l'utiliser ailleurs
module.exports = { db };

let calendar;

// Fonction pour r√©cup√©rer ou cr√©er un thread
async function getOrCreateThreadId(userNumber) {
  try {
    const collection = db.collection('threads1');
    let thread = await collection.findOne({ userNumber });
    if (!thread) {
      const threadResponse = await openai.beta.threads.create();
      const threadId = threadResponse.id;

      await collection.insertOne({ userNumber, threadId, responses: [] });
      return threadId;
    }
    return thread.threadId;
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration ou cr√©ation du thread:', error);
    throw error;
  }
}

// Fonction pour interagir avec OpenAI
async function interactWithAssistant(userMessage, userNumber) {
  try {
    const threadId = await getOrCreateThreadId(userNumber);
    const dateISO = new Date().toLocaleDateString('sv-SE', { timeZone: 'America/Bogota' });
    const heure = new Date().toLocaleTimeString('es-ES', { timeZone: 'America/Bogota' });

    // üí¨ Envoi du message utilisateur
    await openai.beta.threads.messages.create(threadId, {
      role: "user",
      content: `Mensaje del cliente: "${userMessage}". Nota: El n√∫mero WhatsApp del cliente es ${userNumber}. Fecha actual: ${dateISO} Hora actual: ${heure}`
    });
    console.log(`‚úâÔ∏è Message utilisateur ajout√© au thread ${threadId}`);

    // ‚ñ∂Ô∏è Cr√©ation d‚Äôun nouveau run
    const runResponse = await openai.beta.threads.runs.create(threadId, {
      assistant_id: "asst_7gcQiaUIhHn6P9ts1te0Fzpo"
    });
    const runId = runResponse.id;
    console.log(`‚ñ∂Ô∏è Run lanc√© : runId = ${runId}`);

    // ‚è≥ Attente de la compl√©tion
    const messages = await pollForCompletion(threadId, runId);

    return { threadId, runId, messages };
  } catch (error) {
    console.error("‚ùå Erreur dans interactWithAssistant:", error);
    throw error;
  }
}


async function initGoogleCalendarClient() {
    try {
      const serviceAccountJson = process.env.SERVICE_ACCOUNT_KEY; 
      if (!serviceAccountJson) {
        console.error("SERVICE_ACCOUNT_KEY n'est pas d√©fini en variable d'env.");
        return;
      }
      const key = JSON.parse(serviceAccountJson);
      console.log("Compte de service :", key.client_email);
  
      const client = new google.auth.JWT(
        key.client_email,
        null,
        key.private_key,
        ['https://www.googleapis.com/auth/calendar']
      );
      
      await client.authorize();
      calendar = google.calendar({ version: 'v3', auth: client });
      console.log('‚úÖ Client Google Calendar initialis√©');
    } catch (error) {
      console.error("‚ùå Erreur d'init du client Google Calendar :", error);
    }
  }

async function startCalendar() {
  await initGoogleCalendarClient();  // on attend l'init
  if (calendar) {
    try {
      const res = await calendar.calendarList.list();
      console.log('\nüìÖ Agendas disponibles :');
      (res.data.items || []).forEach(cal => {
        console.log(`- ID: ${cal.id}, Summary: ${cal.summary}`);
      });
    } catch (err) {
      console.error("‚ùå Erreur lors de la r√©cup√©ration des agendas :", err);
    }
  }
}
  // Appeler une seule fois :
  startCalendar();

  async function createAppointment(params) {
    // V√©rifier si le client Google Calendar est d√©j√† initialis√©
    if (!calendar) {
      try {
        const serviceAccountJson = process.env.SERVICE_ACCOUNT_KEY;
        if (!serviceAccountJson) {
          console.error("SERVICE_ACCOUNT_KEY n'est pas d√©fini en variable d'env.");
          return { success: false, message: "Service account non configur√©." };
        }
        const key = JSON.parse(serviceAccountJson);
        console.log("Compte de service :", key.client_email);
  
        // Cr√©ation du client JWT
        const client = new google.auth.JWT(
          key.client_email,
          null,
          key.private_key,
          ['https://www.googleapis.com/auth/calendar']
        );
  
        // Authentification
        await client.authorize();
  
        // Initialisation du client Calendar et affectation √† la variable globale
        calendar = google.calendar({ version: 'v3', auth: client });
        console.log('‚úÖ Client Google Calendar initialis√© dans createAppointment');
      } catch (error) {
        console.error("‚ùå Erreur lors de l'initialisation de Google Calendar :", error);
        return { success: false, message: "Erreur d'initialisation de Calendar" };
      }
    }
  
    // √Ä partir d'ici, calendar est garanti d'√™tre d√©fini.
    try {
      // D√©finir l'√©v√©nement √† cr√©er
      const event = {
        summary: `Cita de ${params.customerName}`,
        description: `T√©l√©phone: ${params.phoneNumber}\nService: ${params.service}`,
        start: {
          dateTime: `${params.date}T${params.startTime}:00`, // Ajout des secondes si besoin
          timeZone: 'America/Bogota',
        },
        end: {
          dateTime: `${params.date}T${params.endTime}:00`,
          timeZone: 'America/Bogota',
        },
      };  
  
      // Insertion de l'√©v√©nement dans l'agenda de diegodfr75@gmail.com
      const calendarRes = await calendar.events.insert({
        calendarId: params.calendarId,
        resource: event,
      });
  
      const eventId = calendarRes.data.id;
      console.log('√âv√©nement cr√©√© sur Google Calendar, eventId =', eventId);
  
      // Insertion en base de donn√©es (MongoDB) avec l'eventId
      await db.collection('appointments').insertOne({
        customerName: params.customerName,
        phoneNumber: params.phoneNumber,
        date: params.date,
        startTime: params.startTime,
        endTime: params.endTime,
        service: params.service,
        googleEventId: eventId
      });
  
      return { success: true, message: 'Cita creada en Calendar y Mongo', eventId };
    } catch (error) {
      console.error("Erreur lors de la cr√©ation de l'√©v√©nement :", error);
      return { success: false, message: 'No se pudo crear la cita.' };
    }
  }
  
  
  async function cancelAppointment(phoneNumber) {
    try {
      // 1) Trouver le RDV en base
      const appointment = await db.collection("appointments")
          .findOne({ phoneNumber: params.phoneNumber, calendarId: params.calendarId });
      if (!appointment) {
        console.log("Aucun RDV trouv√© pour ce phoneNumber:", phoneNumber);
        return false;
      }
  
      // 2) Supprimer l‚Äôevent c√¥t√© Google si googleEventId existe
      if (appointment && appointment.googleEventId) {
        await calendar.events.delete({
          calendarId: params.calendarId,
          eventId: appointment.googleEventId
        });
        console.log("√âv√©nement GoogleCalendar supprim√©:", appointment.googleEventId);
      } else {
        console.log("Aucun googleEventId stock√©, on ne supprime rien sur Google.");
      }
  
      // 3) Supprimer en base
      const result = await db.collection('appointments').deleteOne({ _id: appointment._id });
      return result.deletedCount > 0;
    } catch (error) {
      console.error("Erreur cancelAppointment:", error);
      return false;
    }
  }

// V√©rification du statut d'un run
async function pollForCompletion(threadId, runId, userNumber) {
  return new Promise((resolve, reject) => {
    const interval = 2000;
    const timeoutLimit = 80000;
    let elapsedTime = 0;

    let pendingImages = [];

    const checkRun = async () => {
      try {
        const runStatus = await openai.beta.threads.runs.retrieve(threadId, runId);
        console.log(`üìä Estado del run: ${runStatus.status}`);

        if (runStatus.status === 'completed') {
          const messages = await fetchThreadMessages(threadId);
          console.log("üì© R√©ponse finale de l'assistant:", messages);
          resolve(messages);
          return;
        }

        if (
          runStatus.status === 'requires_action' &&
          runStatus.required_action?.submit_tool_outputs?.tool_calls
        ) {
          const toolCalls = runStatus.required_action.submit_tool_outputs.tool_calls;
          const toolOutputs = [];

          for (const toolCall of toolCalls) {
            const { function: fn, id } = toolCall;
            let params;

            try {
              params = JSON.parse(fn.arguments);
            } catch (error) {
              console.error("‚ùå Erreur en parsant les arguments JSON:", error);
              reject(error);
              return;
            }

            switch (fn.name) {
              case "getAppointments": {
                if (!calendar) {
                  await initGoogleCalendarClient(); // au cas o√π non initialis√©
                }
              
                try {
                  const startOfDay = `${params.date}T00:00:00-05:00`; // Bogota timezone
                  const endOfDay = `${params.date}T23:59:59-05:00`;
              
                  const res = await calendar.events.list({
                    calendarId: params.calendarId,
                    timeMin: new Date(startOfDay).toISOString(),
                    timeMax: new Date(endOfDay).toISOString(),
                    singleEvents: true,
                    orderBy: 'startTime',
                  });
              
                  const appointments = res.data.items.map(event => ({
                    start: event.start.dateTime,
                    end: event.end.dateTime,
                    summary: event.summary,
                  }));
              
                  toolOutputs.push({
                    tool_call_id: id,
                    output: JSON.stringify(appointments),
                  });
                } catch (error) {
                  console.error("‚ùå Erreur lors de la r√©cup√©ration des RDV Google Calendar :", error);
                  toolOutputs.push({
                    tool_call_id: id,
                    output: JSON.stringify({ error: "Erreur Google Calendar" }),
                  });
                }
                break;
              }

              case "cancelAppointment": {
                const wasDeleted = await cancelAppointment(params.phoneNumber);

                toolOutputs.push({
                  tool_call_id: id,
                  output: JSON.stringify({
                    success: wasDeleted,
                    message: wasDeleted
                      ? "La cita ha sido cancelada."
                      : "No se encontr√≥ ninguna cita para ese n√∫mero."
                  })
                });
                break;
              }

              case "createAppointment": {
                const result = await createAppointment(params);

                toolOutputs.push({
                  tool_call_id: id,
                  output: JSON.stringify({
                    success: result.success,
                    message: result.message
                  })
                });
                break;
              }

              case "get_image_url": {
                console.log("üñºÔ∏è Demande d'URL image re√ßue:", params);
                const imageUrl = await getImageUrl(params.imageCode);
                console.log("üñºÔ∏è R√©sultat getImageUrl pour", params.imageCode, ":", imageUrl);
                if (imageUrl) pendingImages.push(imageUrl); // üÜï On ajoute √† la liste
                toolOutputs.push({
                  tool_call_id: id,
                  output: JSON.stringify({ imageUrl })
                });
                break;
              }

              case "notificar_comerciante": {
                console.log("üì£ Function calling d√©tect√©e : notificar_comerciante");
                const { estado, numero_cliente } = params;
                await enviarAlertaComerciante(estado, numero_cliente);
                toolOutputs.push({
                  tool_call_id: id,
                  output: JSON.stringify({ success: true })
                });
                break;
              }
              default:
                console.warn(`‚ö†Ô∏è Fonction inconnue (non g√©r√©e) : ${fn.name}`);
            }
          }

          if (toolOutputs.length > 0) {
            await openai.beta.threads.runs.submitToolOutputs(threadId, runId, {
              tool_outputs: toolOutputs
            });
          }

          setTimeout(checkRun, 500);
          return;
        }

        elapsedTime += interval;
        if (elapsedTime >= timeoutLimit) {
          console.error("‚è≥ Timeout (80s), annulation du run...");
          await openai.beta.threads.runs.cancel(threadId, runId);
          reject(new Error("Run annul√© apr√®s 80s sans r√©ponse."));
          return;
        }

        setTimeout(checkRun, interval);

      } catch (error) {
        console.error("Erreur dans pollForCompletion:", error);
        reject(error);
      }
    };

    checkRun();
  });
}

// R√©cup√©rer les messages d'un thread
async function fetchThreadMessages(threadId) {
  try {
    const messagesResponse = await openai.beta.threads.messages.list(threadId);
    const messages = messagesResponse.data.filter(msg => msg.role === 'assistant');

    const latestMessage = messages[0];
    let textContent = latestMessage.content
      .filter(c => c.type === 'text')
      .map(c => c.text.value)
      .join(" ");

    // Extraction des URLs Markdown du texte
    const markdownUrlRegex = /!\[.*?\]\((https?:\/\/[^\s)]+)\)/g;
    let match;
    const markdownImageUrls = [];

    while ((match = markdownUrlRegex.exec(textContent)) !== null) {
      markdownImageUrls.push(match[1]);
    }

    // Nettoyage des URL markdown du texte
    textContent = textContent.replace(markdownUrlRegex, '').trim();

    // Suppression des r√©f√©rences internes „ÄêXX:XX‚Ä†nomfichier.json„Äë
    textContent = textContent.replace(/„Äê\d+:\d+‚Ä†[^\]]+„Äë/g, '').trim();

    // ‚ûï D√©tection et extraction de la nota interna
    let summaryNote = null;
    let statusNote = null;

    const noteStart = textContent.indexOf('--- Nota interna ---');
    if (noteStart !== -1) {
      const noteContent = textContent.slice(noteStart).replace(/[-]+/g, '').trim();

      const resumenMatch = noteContent.match(/Resumen\s*:\s*(.+)/i);
      const estadoMatch = noteContent.match(/Estado\s*:\s*(.+)/i);

      summaryNote = resumenMatch ? resumenMatch[1].trim() : null;
      statusNote = estadoMatch ? estadoMatch[1].trim() : null;

      // Supprimer la note du texte envoy√© au client
      textContent = textContent.slice(0, noteStart).trim();
    }

    // ‚ûï Conversion Markdown OpenAI ‚Üí Markdown WhatsApp
    function convertMarkdownToWhatsApp(text) {
      return text
        .replace(/\*\*(.*?)\*\*/g, '*$1*')          // Gras
        .replace(/\*(.*?)\*/g, '_$1_')              // Italique
        .replace(/~~(.*?)~~/g, '~$1~')              // Barr√©
        .replace(/!\[.*?\]\((.*?)\)/g, '')          // Images
        .replace(/\[(.*?)\]\((.*?)\)/g, '$1 : $2')  // Liens
        .replace(/^>\s?(.*)/gm, '$1')               // Citations
        .replace(/^(\d+)\.\s/gm, '- ')              // Listes
        .trim();
    }

    // Application de la conversion Markdown
    textContent = convertMarkdownToWhatsApp(textContent);

    // R√©cup√©ration des images issues du Function Calling
    const toolMessages = messagesResponse.data.filter(msg => msg.role === 'tool');
    const toolImageUrls = toolMessages
      .map(msg => msg.content?.[0]?.text?.value)
      .filter(url => url && url.startsWith('http'));

    const images = [...markdownImageUrls, ...toolImageUrls];

    // ‚úÖ Retour complet avec note extraite
    return {
      text: textContent,
      images: images,
      note: {
        summary: summaryNote,
        status: statusNote
      }
    };

  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des messages du thread:", error);
    return {
      text: "",
      images: [],
      note: null
    };
  }
}

// Fonction pour r√©cup√©rer les URLs des images depuis MongoDB
async function getImageUrl(imageCode) {
  try {
    const image = await db.collection("images").findOne({ _id: imageCode });

    if (image && image.url) {
      console.log(`‚úÖ URL trouv√©e pour le code "${imageCode}" : ${image.url}`);
    } else {
      console.warn(`‚ö†Ô∏è Aucune URL trouv√©e pour le code "${imageCode}".`);
    }

    return image ? image.url : null;
  } catch (error) {
    console.error("‚ùå Erreur r√©cup√©ration URL image:", error);
    return null;
  }
}

async function sendResponseToWhatsApp(response, userNumber) {
  const { text, images } = response;
  console.log("üì§ Envoi WhatsApp : texte =", text, "images =", images);
  const apiUrl = `https://graph.facebook.com/v16.0/${whatsappPhoneNumberId}/messages`;
  const headers = {
    Authorization: `Bearer ${token}`,
    'Content-Type': 'application/json',
  };

  if (text) {
    await axios.post(apiUrl, {
      messaging_product: 'whatsapp',
      to: userNumber,
      text: { body: text },
    }, { headers });
  }

  if (images && images.length > 0) {
    for (const url of images) {
      if (url) {
        await axios.post(apiUrl, {
          messaging_product: 'whatsapp',
          to: userNumber,
          type: 'image',
          image: { link: url },
        }, { headers });
      }
    }
  }
}

// Modification du endpoint WhatsApp pour g√©rer les images
app.post('/whatsapp', async (req, res) => {
  // üì© Requ√™te re√ßue : log simplifi√©
  try {
    // üìå D√©claration variables
    const entry = req.body?.entry?.[0];
    const changes = entry?.changes?.[0];
    const value = changes?.value;
    const field = changes?.field;
  
    // üö´ Ignorer si ce n'est pas un message entrant
    if (field !== "messages" || !value.messages || !value.messages[0]) {
      return res.status(200).send("Pas un message entrant √† traiter.");
    }
  
    // üìå D√©claration message
    const message = value.messages[0];
    const from = message.from; // num√©ro du client
    const messageId = message.id; // ID unique du message
    const name = value.contacts?.[0]?.profile?.name || "Inconnu";
    const body = message?.text?.body || "üü° Aucun contenu texte";
  
    // ‚úÖ Log propre et lisible
    console.log(`üì• Message re√ßu de ${name} (${from}) : "${body}"`);

    // ‚úÖ V√©rifier si ce message a d√©j√† √©t√© trait√©
    const alreadyProcessed = await db.collection('processedMessages').findOne({ messageId });
    if (alreadyProcessed) {
      console.log("‚ö†Ô∏è Message d√©j√† trait√©, on ignore :", messageId);
      return res.status(200).send("Message d√©j√† trait√©.");
    }
    await db.collection('processedMessages').insertOne({
      messageId,
      createdAt: new Date()
    });

    // üß† Extraire le contenu utilisateur
    let userMessage = '';
    if (message.type === 'text' && message.text.body) {
      userMessage = message.text.body.trim();
    } else if (message.type === 'image') {
      userMessage = "Cliente envi√≥ una imagen.";
    } else if (message.type === 'audio') {
      userMessage = "Cliente envi√≥ un audio.";
    } else {
      userMessage = "Cliente envi√≥ un type de message non g√©r√©.";
    }

    if (!userMessage) {
      return res.status(200).send('Message vide ou non g√©r√©.');
    }

    // üîÑ Envoyer le message √† handleMessage (qui appelle OpenAI + r√©pond au client)
    await handleMessage(userMessage, from);

    res.status(200).send('Message re√ßu et en cours de traitement.');

  } catch (error) {
    console.error("‚ùå Erreur lors du traitement du message WhatsApp :", error);
    res.status(500).json({ error: "Erreur serveur." });
  }
});

app.get('/whatsapp', (req, res) => {
  // R√©cup√®re les param√®tres que Meta envoie
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  // Compare le token re√ßu avec celui que vous avez d√©fini dans Meta for Developers
  if (mode === 'subscribe' && token === 'myVerifyToken123') {
    console.log('WEBHOOK_VERIFIED');
    // Renvoyer challenge pour confirmer la v√©rification
    res.status(200).send(challenge);
  } else {
    // Token ou mode invalide
    res.sendStatus(403);
  }
});

// Endpoint de v√©rification
app.get('/', (req, res) => {
  res.send('Le serveur est op√©rationnel !');
});

// Lancer le serveur
app.listen(PORT, () => {
  console.log(`Le serveur fonctionne sur le port ${PORT}`);
});
